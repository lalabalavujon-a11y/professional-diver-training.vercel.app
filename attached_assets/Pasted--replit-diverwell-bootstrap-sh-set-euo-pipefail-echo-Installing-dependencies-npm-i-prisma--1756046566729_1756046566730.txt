# replit_diverwell_bootstrap.sh
set -euo pipefail

echo "üîß Installing dependencies‚Ä¶"
npm i @prisma/client next-auth bcryptjs zod @auth/prisma-adapter nodemailer resend
npm i -D prisma tsx @types/bcryptjs

echo "üß© Updating package.json scripts‚Ä¶"
node - <<'JS'
const fs=require('fs'); const p='package.json';
const j=JSON.parse(fs.readFileSync(p,'utf8'));
j.scripts=j.scripts||{};
j.scripts.postinstall="prisma generate";
j.scripts["db:push"]="prisma db push";
j.scripts["db:deploy"]="prisma migrate deploy";
j.scripts["db:seed"]="tsx prisma/seed.ts";
j.scripts.dev="next dev -H 0.0.0.0 -p $PORT";
j.scripts.build="prisma generate && next build";
j.scripts.start="next start -H 0.0.0.0 -p $PORT";
fs.writeFileSync(p, JSON.stringify(j,null,2));
console.log("‚úì package.json updated");
JS

echo "üß≠ Ensuring tsconfig aliases‚Ä¶"
node - <<'JS'
const fs=require('fs'); const p='tsconfig.json';
let j={compilerOptions:{}}; if (fs.existsSync(p)) j=JSON.parse(fs.readFileSync(p,'utf8'));
j.compilerOptions.baseUrl='.';
j.compilerOptions.paths=Object.assign({}, j.compilerOptions.paths||{}, {"@/*":["src/*"], "lib/*":["src/lib/*"]});
fs.writeFileSync(p, JSON.stringify(j,null,2));
console.log("‚úì tsconfig.json aliases set");
JS

echo "üìÅ Creating folders‚Ä¶"
mkdir -p prisma src/lib src/components \
  src/app/api/auth/[...nextauth] \
  src/app/api/health \
  src/app/api/quiz/submit \
  src/app/tracks/[slug] \
  src/app/lessons/[id]/quiz \
  src/app/lessons/[id] \
  src/app/admin/users \
  src/app/api/admin/users/set-role \
  src/app/api/admin/exports/attempts \
  src/app/api/admin/invites \
  src/app/api/admin/invites/[token] \
  src/app/admin/invites \
  src/app/invite/[token] \
  src/app/api/admin/lessons/[id] \
  src/app/admin/lessons/[id] \
  src/app/api/admin/quiz/[lessonId]/questions \
  src/app/api/admin/quiz/[lessonId]

echo "üóÑÔ∏è Writing Prisma schema‚Ä¶"
cat > prisma/schema.prisma <<'PRISMA'
generator client { provider = "prisma-client-js" }

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  relationMode = "foreignKeys"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String?
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  attempts  Attempt[]
  accounts  Account[]
  sessions  Session[]
}

enum Role { USER ADMIN }

model Track {
  id        String   @id @default(cuid())
  title     String
  slug      String   @unique
  summary   String?
  createdAt DateTime @default(now())
  lessons   Lesson[]
}

model Lesson {
  id        String   @id @default(cuid())
  trackId   String
  title     String
  order     Int      @default(0)
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  track     Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  quizzes   Quiz[]
}

model Quiz {
  id        String    @id @default(cuid())
  lessonId  String
  title     String
  questions Question[]
  lesson    Lesson    @relation(fields: [lessonId], references: [id], onDelete: Cascade)
}

model Question {
  id        String  @id @default(cuid())
  quizId    String
  prompt    String
  a         String
  b         String
  c         String
  d         String
  answer    String
  quiz      Quiz     @relation(fields: [quizId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

model Attempt {
  id        String   @id @default(cuid())
  userId    String
  quizId    String
  score     Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  quiz      Quiz     @relation(fields: [quizId], references: [id], onDelete: Cascade)
}

/* NextAuth adapter models */
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?  @db.Text
  access_token      String?  @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?  @db.Text
  session_state     String?
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

/* Invites */
model Invite {
  id         String   @id @default(cuid())
  email      String
  role       Role     @default(USER)
  token      String   @unique
  expiresAt  DateTime
  acceptedAt DateTime?
  revokedAt  DateTime?
  createdAt  DateTime @default(now())
  createdBy  String?

  @@index([email, expiresAt])
}
PRISMA

echo "üîå Prisma client helper‚Ä¶"
cat > src/lib/prisma.ts <<'TS'
import { PrismaClient } from "@prisma/client"
declare global { var prisma: PrismaClient | undefined }
export const prisma = global.prisma ?? new PrismaClient()
if (process.env.NODE_ENV !== "production") global.prisma = prisma
TS

echo "üîê Auth helpers‚Ä¶"
cat > src/lib/auth.ts <<'TS'
import { getServerSession } from "next-auth"
import { prisma } from "@/lib/prisma"

export async function requireUser() {
  const session = await getServerSession()
  if (!session?.user?.email) throw new Error("UNAUTHENTICATED")
  const user = await prisma.user.findUnique({ where: { email: session.user.email }, select: { id: true, role: true, email: true } })
  if (!user) throw new Error("UNAUTHENTICATED")
  return user
}
export async function requireAdmin() {
  const user = await requireUser()
  if (user.role !== "ADMIN") throw new Error("FORBIDDEN")
  return user
}
TS

echo "üå± Seed script‚Ä¶"
cat > prisma/seed.ts <<'TS'
import { prisma } from "@/lib/prisma"

async function main() {
  const tracks = [
    { title: "Physiology Basics", slug: "physiology", summary: "Core physiology concepts (brand-neutral)" },
    { title: "Decompression", slug: "decompression", summary: "Theory & practice (brand-neutral)" },
  ]
  for (const t of tracks) {
    const track = await prisma.track.upsert({ where: { slug: t.slug }, update: {}, create: t })
    const lessonId = `${track.id}-intro`
    await prisma.lesson.upsert({
      where: { id: lessonId },
      update: {},
      create: { id: lessonId, trackId: track.id, title: `${t.title} ‚Äî Intro`, order: 1, content: "Welcome to Diver Well Training." },
    })
    const quiz = await prisma.quiz.upsert({
      where: { id: `${lessonId}-quiz` },
      update: {},
      create: { id: `${lessonId}-quiz`, lessonId, title: `${t.title} ‚Äî Quick Check` }
    })
    await prisma.question.upsert({
      where: { id: `${quiz.id}-q1` },
      update: {},
      create: {
        id: `${quiz.id}-q1`, quizId: quiz.id,
        prompt: "Which statement best describes gas laws relevance to diving?",
        a: "They are unrelated to depth.",
        b: "They affect gas volume and pressure with depth.",
        c: "They only matter above water.",
        d: "Only relevant for non-compressed gases.",
        answer: "b"
      }
    })
    await prisma.question.upsert({
      where: { id: `${quiz.id}-q2` },
      update: {},
      create: {
        id: `${quiz.id}-q2`, quizId: quiz.id,
        prompt: "What is a safe practice before ascent?",
        a: "Rapid ascent to minimize time.",
        b: "Ignore stop plans if feeling fine.",
        c: "Follow planned stops and ascent rate.",
        d: "Hold breath to conserve air.",
        answer: "c"
      }
    })
  }
  const bcrypt = await import("bcryptjs")
  const hash = await bcrypt.hash("admin123", 12)
  await prisma.user.upsert({
    where: { email: "admin@diverwell.app" },
    update: {},
    create: { email: "admin@diverwell.app", password: hash, role: "ADMIN", name: "Admin" },
  })
}
main().then(()=>process.exit(0)).catch(e=>{console.error(e);process.exit(1)})
TS

echo "üß± Layout & error‚Ä¶"
cat > src/app/layout.tsx <<'TSX'
export const runtime = "nodejs"
export const dynamic = "force-dynamic"
import "./globals.css"
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return <html lang="en"><body className="min-h-screen bg-white text-slate-900">{children}</body></html>
}
TSX

cat > src/app/error.tsx <<'TSX'
"use client"
import { useEffect } from "react"
export default function GlobalError({ error }: { error: Error & { digest?: string } }) {
  useEffect(() => console.error("GlobalError", error), [error])
  return <html><body><h1>Something went wrong</h1><p>Digest: {error?.digest}</p></body></html>
}
TSX

echo "üìä ProgressBar component‚Ä¶"
cat > src/components/ProgressBar.tsx <<'TSX'
export default function ProgressBar({ value }: { value: number }) {
  const pct = Math.max(0, Math.min(100, Math.round(value)))
  return (
    <div className="h-3 w-full bg-slate-200 rounded">
      <div className="h-3 bg-slate-800 rounded" style={{ width: `${pct}%` }} />
    </div>
  )
}
TSX

echo "üìù QuizForm component‚Ä¶"
cat > src/components/QuizForm.tsx <<'TSX'
"use client"
import { useState } from "react"
type Question = { id: string; prompt: string; a: string; b: string; c: string; d: string }
export default function QuizForm({ quizId, questions }: { quizId: string; questions: Question[] }) {
  const [answers, setAnswers] = useState<Record<string, string>>({})
  const [result, setResult] = useState<{ score: number; total: number } | null>(null)
  const [submitting, setSubmitting] = useState(false)
  const onChange = (qid: string, value: string) => setAnswers((s) => ({ ...s, [qid]: value }))
  async function onSubmit(e: React.FormEvent) {
    e.preventDefault(); setSubmitting(true)
    try {
      const resp = await fetch("/api/quiz/submit", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ quizId, answers }) })
      if (!resp.ok) throw new Error("Submit failed")
      const data = await resp.json()
      setResult({ score: data.score, total: data.total })
    } catch { alert("There was a problem submitting the quiz.") } finally { setSubmitting(false) }
  }
  if (result) return <div className="mt-6"><h2 className="text-xl font-semibold">Your score</h2><p className="mt-2">{result.score} / {result.total}</p><a className="underline mt-4 inline-block" href="/dashboard">View dashboard</a></div>
  return (
    <form onSubmit={onSubmit} className="space-y-6">
      {questions.map((q, i) => (
        <div key={q.id} className="border rounded p-4">
          <div className="font-medium">{i + 1}. {q.prompt}</div>
          <div className="mt-2 grid gap-2">
            {(["a","b","c","d"] as const).map((k) => (
              <label key={k} className="flex gap-2 items-center">
                <input type="radio" name={q.id} value={k} checked={answers[q.id] === k} onChange={() => onChange(q.id, k)} />
                <span>{(q as any)[k]}</span>
              </label>
            ))}
          </div>
        </div>
      ))}
      <button disabled={submitting} className="border px-4 py-2">{submitting ? "Submitting‚Ä¶" : "Submit"}</button>
    </form>
  )
}
TSX

echo "üè† Home with track progress‚Ä¶"
cat > src/app/page.tsx <<'TSX'
import { prisma } from "@/lib/prisma"
import { getServerSession } from "next-auth"
import ProgressBar from "@/components/ProgressBar"
export const runtime = "nodejs"; export const dynamic = "force-dynamic";

export default async function Home() {
  const session = await getServerSession()
  const user = session?.user?.email ? await prisma.user.findUnique({ where: { email: session.user.email }, select: { id: true } }) : null
  const tracks = await prisma.track.findMany({ orderBy: { title: "asc" } })
  async function trackProgress(trackId: string) {
    const total = await prisma.quiz.count({ where: { lesson: { trackId } } })
    if (!user || total === 0) return 0
    const completed = await prisma.attempt.findMany({ where: { userId: user.id, quiz: { lesson: { trackId } } }, distinct: ["quizId"], select: { quizId: true } })
    return Math.round((completed.length / total) * 100)
  }
  const items = await Promise.all(tracks.map(async t => ({ t, pct: await trackProgress(t.id) })))
  return (
    <main className="max-w-3xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-4">Diver Well Training</h1>
      <ul className="space-y-4">
        {items.map(({ t, pct }) => (
          <li key={t.id}>
            <a className="underline" href={`/tracks/${t.slug}`}>{t.title}</a>
            <div className="mt-2"><ProgressBar value={pct} /><div className="text-xs mt-1">{pct}% complete</div></div>
          </li>
        ))}
      </ul>
    </main>
  )
}
TSX

echo "üß≠ Track page‚Ä¶"
cat > src/app/tracks/[slug]/page.tsx <<'TSX'
import { prisma } from "@/lib/prisma"
import { getServerSession } from "next-auth"
import ProgressBar from "@/components/ProgressBar"
export const runtime = "nodejs"; export const dynamic = "force-dynamic";

export default async function TrackPage({ params }: { params: { slug: string } }) {
  const track = await prisma.track.findUnique({ where: { slug: params.slug }, include: { lessons: { orderBy: { order: "asc" } } } })
  if (!track) return <div className="p-6">Not found</div>
  const session = await getServerSession()
  const user = session?.user?.email ? await prisma.user.findUnique({ where: { email: session.user.email }, select: { id: true } }) : null
  const total = await prisma.quiz.count({ where: { lesson: { trackId: track.id } } })
  let pct = 0
  if (user && total > 0) {
    const completed = await prisma.attempt.findMany({ where: { userId: user.id, quiz: { lesson: { trackId: track.id } } }, distinct: ["quizId"], select: { quizId: true } })
    pct = Math.round((completed.length / total) * 100)
  }
  return (
    <div className="max-w-3xl mx-auto p-6">
      <a className="underline text-sm" href="\/">‚Üê Back</a>
      <h1 className="text-2xl font-bold">{track.title}</h1>
      <p className="mt-2 text-slate-600">{track.summary}</p>
      <div className="mt-4"><ProgressBar value={pct} /><div className="text-xs mt-1">{pct}% complete</div></div>
      <ul className="mt-6 space-y-2">
        {track.lessons.map(l => (
          <li key={l.id}>
            <a className="underline" href={`/lessons/${l.id}`}>{l.title}</a>{" "}
            <a className="text-sm underline ml-2" href={`/lessons/${l.id}/quiz`}>Take quiz</a>
          </li>
        ))}
      </ul>
    </div>
  )
}
TSX

echo "üìñ Lesson page‚Ä¶"
cat > src/app/lessons/[id]/page.tsx <<'TSX'
import { prisma } from "@/lib/prisma"
export const runtime = "nodejs"; export const dynamic = "force-dynamic";
export default async function Lesson({ params }: { params: { id: string } }) {
  const lesson = await prisma.lesson.findUnique({ where: { id: params.id } })
  if (!lesson) return <div className="p-6">Not found</div>
  return (
    <div className="max-w-3xl mx-auto p-6">
      <a className="underline text-sm" href="/">‚Üê Back</a>
      <h1 className="text-2xl font-bold mt-2">{lesson.title}</h1>
      <a className="text-xs underline ml-2" href={`/admin/lessons/${lesson.id}`}>Edit</a>
      <article className="prose mt-6 whitespace-pre-wrap">{lesson.content}</article>
    </div>
  )
}
TSX

echo "üìù Lesson quiz page‚Ä¶"
cat > src/app/lessons/[id]/quiz/page.tsx <<'TSX'
import { prisma } from "@/lib/prisma"
import QuizForm from "@/components/QuizForm"
export const runtime = "nodejs"; export const dynamic = "force-dynamic";

export default async function LessonQuiz({ params }: { params: { id: string } }) {
  const lesson = await prisma.lesson.findUnique({ where: { id: params.id } })
  if (!lesson) return <div className="p-6">Not found</div>
  const quiz = await prisma.quiz.findFirst({ where: { lessonId: lesson.id }, include: { questions: true } })
  if (!quiz) return <div className="max-w-3xl mx-auto p-6"><a className="underline text-sm" href={`/lessons/${lesson.id}`}>‚Üê Back to lesson</a><h1 className="text-2xl font-bold mt-2">No quiz available</h1></div>
  return (
    <div className="max-w-3xl mx-auto p-6">
      <a className="underline text-sm" href={`/lessons/${lesson.id}`}>‚Üê Back to lesson</a>
      <h1 className="text-2xl font-bold mt-2">{lesson.title} ‚Äî Quiz</h1>
      <QuizForm quizId={quiz.id} questions={quiz.questions as any} />
    </div>
  )
}
TSX

echo "üß™ Quiz submit API‚Ä¶"
cat > src/app/api/quiz/submit/route.ts <<'TS'
export const runtime = "nodejs"
import { NextResponse } from "next/server"
import { getServerSession } from "next-auth"
import { prisma } from "@/lib/prisma"

export async function POST(req: Request) {
  const session = await getServerSession()
  if (!session?.user?.email) return NextResponse.json({ error: "UNAUTHENTICATED" }, { status: 401 })
  const body = await req.json().catch(() => null) as { quizId?: string; answers?: Record<string,string> } | null
  if (!body?.quizId || !body.answers) return NextResponse.json({ error: "BAD_REQUEST" }, { status: 400 })
  const quiz = await prisma.quiz.findUnique({ where: { id: body.quizId }, include: { questions: true } })
  if (!quiz) return NextResponse.json({ error: "NOT_FOUND" }, { status: 404 })
  const total = quiz.questions.length
  let score = 0; for (const q of quiz.questions) { const picked = body.answers[q.id]; if (picked && picked === q.answer) score++ }
  const user = await prisma.user.findUnique({ where: { email: session.user.email! } })
  if (!user) return NextResponse.json({ error: "NO_USER" }, { status: 401 })
  await prisma.attempt.create({ data: { userId: user.id, quizId: quiz.id, score } })
  return NextResponse.json({ score, total })
}
TS

echo "‚ù§Ô∏è Health API‚Ä¶"
cat > src/app/api/health/route.ts <<'TS'
export const runtime = "nodejs"
import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
export async function GET() {
  try { await prisma.$queryRaw`SELECT 1`; return NextResponse.json({ ok: true }) }
  catch (e: any) { console.error("HEALTH ERROR", e?.message); return NextResponse.json({ ok: false }, { status: 500 }) }
}
TS

echo "üîè NextAuth (Email + Credentials + Adapter)‚Ä¶"
cat > src/app/api/auth/[...nextauth]/route.ts <<'TS'
import NextAuth from "next-auth"
import Credentials from "next-auth/providers/credentials"
import Email from "next-auth/providers/email"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { prisma } from "@/lib/prisma"
import bcrypt from "bcryptjs"
import nodemailer from "nodemailer"
import { Resend } from "resend"

const useResend = Boolean(process.env.RESEND_API_KEY)
const resend = useResend ? new Resend(process.env.RESEND_API_KEY) : null

const auth = NextAuth({
  adapter: PrismaAdapter(prisma) as any,
  session: { strategy: "jwt" },
  providers: [
    Email({
      from: process.env.EMAIL_FROM,
      async sendVerificationRequest({ identifier, url, provider }) {
        const subject = "Sign in to Diver Well"
        const html = `<p>Click to sign in:</p><p><a href="${url}">Sign in</a></p>`
        const text = `Sign in: ${url}`
        if (useResend && resend) {
          await resend.emails.send({ from: provider.from as string, to: [identifier], subject, html, text })
        } else if (process.env.EMAIL_SERVER) {
          const transporter = nodemailer.createTransport(process.env.EMAIL_SERVER)
          await transporter.sendMail({ to: identifier, from: provider.from as string, subject, html, text })
        } else {
          throw new Error("No email provider configured (set RESEND_API_KEY or EMAIL_SERVER)")
        }
      },
    }),
    Credentials({
      name: "Credentials",
      credentials: { email: {}, password: {} },
      async authorize(c) {
        if (!c?.email || !c?.password) return null
        const user = await prisma.user.findUnique({ where: { email: c.email } })
        if (!user) return null
        const ok = await bcrypt.compare(c.password, user.password)
        return ok ? { id: user.id, email: user.email, name: user.name, role: user.role } : null
      },
    }),
  ],
  callbacks: {
    async signIn({ user, account }) {
      if (account?.provider === "credentials") return true
      if (process.env.INVITES_REQUIRED === "true") {
        const invited = await prisma.invite.findFirst({
          where: { email: (user.email || "").toLowerCase(), revokedAt: null, expiresAt: { gt: new Date() } },
          orderBy: { createdAt: "desc" },
        })
        if (!invited) return false
        await prisma.user.update({ where: { id: user.id as string }, data: { role: invited.role } }).catch(() => {})
        await prisma.invite.update({ where: { token: invited.token }, data: { acceptedAt: new Date() } }).catch(() => {})
      }
      return true
    },
  },
})
export const GET = auth.handlers.GET
export const POST = auth.handlers.POST
export const runtime = "nodejs"
TS

echo "üë• Admin: users role page & API‚Ä¶"
cat > src/app/api/admin/users/set-role/route.ts <<'TS'
export const runtime = "nodejs"
import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { requireAdmin } from "@/lib/auth"

type Body = { email?: string; role?: "ADMIN" | "USER" }
export async function POST(req: Request) {
  await requireAdmin()
  const body = (await req.json().catch(() => ({}))) as Body
  const email = body.email?.trim().toLowerCase()
  const role = body.role
  if (!email || (role !== "ADMIN" && role !== "USER")) return NextResponse.json({ error: "BAD_REQUEST" }, { status: 400 })
  const user = await prisma.user.findUnique({ where: { email } })
  if (!user) return NextResponse.json({ error: "NOT_FOUND" }, { status: 404 })
  const updated = await prisma.user.update({ where: { id: user.id }, data: { role } })
  return NextResponse.json({ ok: true, user: { id: updated.id, email: updated.email, role: updated.role } })
}
TS

cat > src/app/admin/users/page.tsx <<'TSX'
import { prisma } from "@/lib/prisma"
import { requireAdmin } from "@/lib/auth"
export const runtime = "nodejs"; export const dynamic = "force-dynamic";

export default async function AdminUsers() {
  await requireAdmin()
  const users = await prisma.user.findMany({ orderBy: { createdAt: "desc" }, select: { id: true, email: true, role: true, createdAt: true } })
  return (
    <div className="max-w-3xl mx-auto p-6">
      <a className="underline text-sm" href="/dashboard">‚Üê Back</a>
      <h1 className="text-2xl font-bold mt-2">Admin ‚Ä¢ Users</h1>
      <GrantForm />
      <table className="w-full text-sm border mt-6">
        <thead className="bg-slate-100"><tr><th className="p-2 text-left">Email</th><th className="p-2">Role</th><th className="p-2">Actions</th></tr></thead>
        <tbody>
          {users.map(u => (
            <tr key={u.id} className="border-t">
              <td className="p-2">{u.email}</td>
              <td className="p-2">{u.role}</td>
              <td className="p-2">
                <RoleButtons email={u.email} role={u.role} />
              </td>
            </tr>
          ))}
        </tbody>
      </table>
      <div className="mt-8">
        <h2 className="font-semibold">Exports</h2>
        <a className="underline" href="/api/admin/exports/attempts">Download Attempts CSV</a>
      </div>
    </div>
  )
}
function GrantForm() {
  return (
    <form action={grantAction} className="mt-4 flex gap-2">
      <input name="email" type="email" required placeholder="user@example.com" className="border p-2 flex-1" />
      <select name="role" className="border p-2"><option value="ADMIN">ADMIN</option><option value="USER">USER</option></select>
      <button className="border px-3 py-2">Set Role</button>
    </form>
  )
}
async function grantAction(formData: FormData) {
  "use server"
  const email = String(formData.get("email")||"").trim()
  const role = String(formData.get("role")||"USER") as "ADMIN"|"USER"
  await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || ""}/api/admin/users/set-role`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ email, role }) })
}
function RoleButtons({ email, role }: { email: string; role: string }) {
  return (
    <form action={toggleAction.bind(null, email)} className="inline-flex gap-2">
      <input type="hidden" name="email" value={email} />
      <button name="role" value="ADMIN" className="border px-2 py-1" disabled={role==="ADMIN"}>Grant ADMIN</button>
      <button name="role" value="USER" className="border px-2 py-1" disabled={role==="USER"}>Revoke ADMIN</button>
    </form>
  )
}
async function toggleAction(email: string, formData: FormData) {
  "use server"
  const role = String(formData.get("role")||"USER") as "ADMIN"|"USER"
  await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || ""}/api/admin/users/set-role`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ email, role }) })
}
TSX

echo "üì§ CSV export API‚Ä¶"
cat > src/app/api/admin/exports/attempts/route.ts <<'TS'
export const runtime = "nodejs"
import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { requireAdmin } from "@/lib/auth"

function csvEscape(v: any) { const s = String(v ?? ""); return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s }

export async function GET(req: Request) {
  await requireAdmin()
  const { searchParams } = new URL(req.url)
  const from = searchParams.get("from"), to = searchParams.get("to")
  const where:any = {}
  if (from || to) { where.createdAt = {}; if (from) where.createdAt.gte = new Date(from+"T00:00:00Z"); if (to) where.createdAt.lte = new Date(to+"T23:59:59Z") }
  const rows = await prisma.attempt.findMany({
    where, orderBy: { createdAt: "desc" },
    include: { user: { select: { email: true } }, quiz: { include: { lesson: { include: { track: true } } } } },
  })
  const header = ["email","track","lesson","quiz","score","createdAt"]
  const data = rows.map(r => [r.user?.email||"", r.quiz.lesson.track.title, r.quiz.lesson.title, r.quiz.title, r.score, r.createdAt.toISOString()])
  const csv = [header, ...data].map(line => line.map(csvEscape).join(",")).join("\n")
  return new NextResponse(csv, { status:200, headers:{ "Content-Type":"text/csv; charset=utf-8", "Content-Disposition":'attachment; filename="attempts.csv"' } })
}
TS

echo "‚úâÔ∏è Invites APIs & UI‚Ä¶"
cat > src/app/api/admin/invites/route.ts <<'TS'
export const runtime = "nodejs"
import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { requireAdmin } from "@/lib/auth"
import crypto from "crypto"

export async function GET() {
  await requireAdmin()
  const rows = await prisma.invite.findMany({ orderBy: { createdAt: "desc" }, take: 100 })
  return NextResponse.json({ invites: rows })
}
export async function POST(req: Request) {
  await requireAdmin()
  const { email, role, days } = await req.json().catch(()=>({}))
  if (!email) return NextResponse.json({ error:"email required" }, { status:400 })
  const token = crypto.randomBytes(24).toString("hex")
  const expiresAt = new Date(Date.now() + 1000*60*60*24*(Number(days)||7))
  const inv = await prisma.invite.create({ data: { email: String(email).toLowerCase(), role: role==="ADMIN"?"ADMIN":"USER", token, expiresAt } })
  return NextResponse.json({ invite: inv, link: `/invite/${token}` })
}
TS

cat > src/app/api/admin/invites/[token]/route.ts <<'TS'
export const runtime = "nodejs"
import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { requireAdmin } from "@/lib/auth"
export async function POST(_req: Request, { params }: { params: { token: string } }) {
  await requireAdmin()
  await prisma.invite.update({ where: { token: params.token }, data: { revokedAt: new Date() } }).catch(()=>{})
  return NextResponse.json({ ok: true })
}
TS

cat > src/app/admin/invites/page.tsx <<'TSX'
import { requireAdmin } from "@/lib/auth"
export const runtime = "nodejs"; export const dynamic = "force-dynamic";

export default async function AdminInvites() {
  await requireAdmin()
  const res = await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || ""}/api/admin/invites`, { cache: "no-store" })
  const { invites } = await res.json()
  return (
    <div className="max-w-3xl mx-auto p-6">
      <a className="underline text-sm" href="/dashboard">‚Üê Back</a>
      <h1 className="text-2xl font-bold mt-2">Admin ‚Ä¢ Invites</h1>
      <form action={createAction} className="mt-4 flex gap-2">
        <input name="email" type="email" required placeholder="user@example.com" className="border p-2 flex-1" />
        <select name="role" className="border p-2"><option>USER</option><option>ADMIN</option></select>
        <input name="days" type="number" min={1} defaultValue={7} className="border p-2 w-24" />
        <button className="border px-3 py-2">Create Invite</button>
      </form>
      <ul className="mt-6 space-y-2">
        {invites.map((i: any) => (
          <li key={i.id} className="border p-3 flex items-center justify-between">
            <div>
              <div className="font-mono text-sm">{i.email} ‚Ä¢ {i.role}</div>
              <div className="text-xs text-slate-600">/invite/{i.token} ‚Ä¢ Expires {new Date(i.expiresAt).toLocaleString()} {i.revokedAt?"(revoked)":""} {i.acceptedAt?"(accepted)":""}</div>
            </div>
            <form action={revokeAction.bind(null, i.token)}><button className="border px-2 py-1" disabled={!!i.revokedAt}>Revoke</button></form>
          </li>
        ))}
      </ul>
    </div>
  )
}
async function createAction(formData: FormData) {
  "use server"
  const email = String(formData.get("email")||"").trim()
  const role = String(formData.get("role")||"USER")
  const days = String(formData.get("days")||"7")
  await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || ""}/api/admin/invites`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ email, role, days }) })
}
async function revokeAction(token: string) {
  "use server"
  await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || ""}/api/admin/invites/${token}`, { method: "POST" })
}
TSX

cat > src/app/invite/[token]/page.tsx <<'TSX'
import { prisma } from "@/lib/prisma"
import { redirect } from "next/navigation"

export const runtime = "nodejs"; export const dynamic = "force-dynamic";

export default async function Invite({ params }: { params: { token: string } }) {
  const inv = await prisma.invite.findUnique({ where: { token: params.token } })
  if (!inv || inv.revokedAt || inv.expiresAt < new Date()) return <div className="p-6">Invite invalid or expired.</div>
  return (
    <div className="max-w-md mx-auto p-6">
      <h1 className="text-2xl font-bold">You‚Äôre invited</h1>
      <p className="mt-2 text-slate-700">Sign in with <b>{inv.email}</b>. We‚Äôll email you a one-time link.</p>
      <InviteForm email={inv.email} />
    </div>
  )
}
function InviteForm({ email }: { email: string }) {
  return <form action={action.bind(null, email)} className="mt-4 flex gap-2"><button className="border px-4 py-2">Send magic link</button></form>
}
async function action(email: string) {
  "use server"
  return redirect(`/api/auth/signin?callbackUrl=/&email=${encodeURIComponent(email)}`)
}
TSX

echo "üõ†Ô∏è Lesson content edit API & UI‚Ä¶"
cat > src/app/api/admin/lessons/[id]/route.ts <<'TS'
export const runtime = "nodejs"
import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { requireAdmin } from "@/lib/auth"

export async function GET(_: Request, { params }: { params: { id: string } }) {
  await requireAdmin()
  const lesson = await prisma.lesson.findUnique({ where: { id: params.id } })
  return NextResponse.json({ lesson })
}
export async function PATCH(req: Request, { params }: { params: { id: string } }) {
  await requireAdmin()
  const body = await req.json().catch(() => ({})) as { title?: string; content?: string }
  const updated = await prisma.lesson.update({ where: { id: params.id }, data: { title: body.title, content: body.content } })
  return NextResponse.json({ lesson: updated })
}
TS

cat > src/app/admin/lessons/[id]/page.tsx <<'TSX'
import { requireAdmin } from "@/lib/auth"
export const runtime = "nodejs"; export const dynamic = "force-dynamic";

export default async function EditLesson({ params }: { params: { id: string } }) {
  await requireAdmin()
  const res = await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || ""}/api/admin/lessons/${params.id}`, { cache: "no-store" })
  const { lesson } = await res.json()
  if (!lesson) return <div className="p-6">Not found</div>
  return (
    <div className="max-w-3xl mx-auto p-6">
      <a className="underline text-sm" href={`/lessons/${lesson.id}`}>‚Üê Back</a>
      <h1 className="text-2xl font-bold mt-2">Edit Lesson</h1>
      <EditorForm id={lesson.id} title={lesson.title} content={lesson.content} />
    </div>
  )
}
function EditorForm({ id, title, content }: { id: string; title: string; content: string }) {
  return (
    <form action={saveAction.bind(null, id)} className="mt-4 space-y-3">
      <input name="title" defaultValue={title} className="border p-2 w-full" />
      <textarea name="content" defaultValue={content} className="border p-2 w-full h-64 font-mono" />
      <button className="border px-3 py-2">Save</button>
    </form>
  )
}
async function saveAction(id: string, formData: FormData) {
  "use server"
  const title = String(formData.get("title")||"")
  const content = String(formData.get("content")||"")
  await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || ""}/api/admin/lessons/${id}`, { method: "PATCH", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ title, content }) })
}
TSX

echo "üß∞ Admin quiz editor API & UI‚Ä¶"
cat > src/app/api/admin/quiz/[lessonId]/route.ts <<'TS'
export const runtime = "nodejs"
import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { requireAdmin } from "@/lib/auth"

export async function GET(_: Request, { params }: { params: { lessonId: string } }) {
  await requireAdmin()
  const quiz = await prisma.quiz.findFirst({ where: { lessonId: params.lessonId }, include: { questions: { orderBy: { createdAt: "asc" } } } })
  return NextResponse.json({ quiz })
}
export async function POST(req: Request, { params }: { params: { lessonId: string } }) {
  await requireAdmin()
  const body = await req.json().catch(() => null) as { title?: string } | null
  const title = body?.title || "Lesson Quiz"
  const quiz = await prisma.quiz.upsert({ where: { id: `${params.lessonId}-quiz` }, update: { title }, create: { id: `${params.lessonId}-quiz`, lessonId: params.lessonId, title } })
  return NextResponse.json({ quiz })
}
TS

cat > src/app/api/admin/quiz/[lessonId]/questions/route.ts <<'TS'
export const runtime = "nodejs"
import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { requireAdmin } from "@/lib/auth"

type Payload = {
  action: "create" | "update" | "delete"
  question?: { id?: string; prompt: string; a: string; b: string; c: string; d: string; answer: "a"|"b"|"c"|"d" }
  id?: string
}
export async function POST(req: Request, { params }: { params: { lessonId: string } }) {
  await requireAdmin()
  const body = await req.json().catch(() => null) as Payload | null
  if (!body) return NextResponse.json({ error: "BAD_REQUEST" }, { status: 400 })
  const quiz = await prisma.quiz.upsert({ where: { id: `${params.lessonId}-quiz` }, update: {}, create: { id: `${params.lessonId}-quiz`, lessonId: params.lessonId, title: "Lesson Quiz" } })
  if (body.action === "create" && body.question) {
    const q = await prisma.question.create({ data: { ...body.question, quizId: quiz.id } })
    return NextResponse.json({ ok: true, question: q })
  }
  if (body.action === "update" && body.question?.id) {
    const q = await prisma.question.update({ where: { id: body.question.id }, data: { prompt: body.question.prompt, a: body.question.a, b: body.question.b, c: body.question.c, d: body.question.d, answer: body.question.answer } })
    return NextResponse.json({ ok: true, question: q })
  }
  if (body.action === "delete" && body.id) {
    await prisma.question.delete({ where: { id: body.id } })
    return NextResponse.json({ ok: true })
  }
  return NextResponse.json({ error: "BAD_REQUEST" }, { status: 400 })
}
TS

cat > src/components/AdminQuizEditor.tsx <<'TSX'
"use client"
import { useEffect, useState } from "react"
type Q = { id: string; prompt: string; a: string; b: string; c: string; d: string; answer: "a"|"b"|"c"|"d" }

export default function AdminQuizEditor({ lessonId }: { lessonId: string }) {
  const [title, setTitle] = useState("Lesson Quiz")
  const [questions, setQuestions] = useState<Q[]>([])
  const [loading, setLoading] = useState(true)
  async function load() {
    setLoading(true)
    const r = await fetch(`/api/admin/quiz/${lessonId}`); const j = await r.json()
    setTitle(j.quiz?.title || "Lesson Quiz"); setQuestions(j.quiz?.questions || []); setLoading(false)
  }
  useEffect(() => { load() }, [lessonId])
  async function saveTitle() { await fetch(`/api/admin/quiz/${lessonId}`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ title }) }) }
  async function createQuestion() {
    const q = { prompt: "", a: "", b: "", c: "", d: "", answer: "a" as const }
    const r = await fetch(`/api/admin/quiz/${lessonId}/questions`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ action: "create", question: q }) })
    const j = await r.json(); setQuestions((s) => [...s, j.question])
  }
  async function updateQuestion(q: Q) {
    await fetch(`/api/admin/quiz/${lessonId}/questions`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ action: "update", question: q }) })
  }
  async function deleteQuestion(id: string) {
    await fetch(`/api/admin/quiz/${lessonId}/questions`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ action: "delete", id }) })
    setQuestions((s) => s.filter(x => x.id !== id))
  }
  if (loading) return <div>Loading‚Ä¶</div>
  return (
    <div className="space-y-4">
      <div className="flex items-center gap-2">
        <input className="border p-2 flex-1" value={title} onChange={(e)=>setTitle(e.target.value)} placeholder="Quiz title" />
        <button className="border px-3 py-2" onClick={saveTitle}>Save title</button>
        <button className="border px-3 py-2" onClick={createQuestion}>+ Add question</button>
      </div>
      <div className="space-y-4">
        {questions.map((q, idx) => (
          <div key={q.id} className="border rounded p-4">
            <div className="font-semibold mb-2">Q{idx + 1}</div>
            <input className="border p-2 w-full mb-2" value={q.prompt} onChange={e=>setQuestions(prev=>prev.map(x=>x.id===q.id?{...x,prompt:e.target.value}:x))} placeholder="Prompt" />
            {(["a","b","c","d"] as const).map(k => (
              <div key={k} className="flex items-center gap-2 mb-2">
                <label className="w-6 uppercase">{k}.</label>
                <input className="border p-2 flex-1" value={(q as any)[k]} onChange={e=>setQuestions(prev=>prev.map(x=>x.id===q.id?{...x,[k]:e.target.value}:x))} />
                <label className="flex items-center gap-1 text-sm">
                  <input type="radio" name={`ans-${q.id}`} checked={q.answer===k} onChange={()=>setQuestions(prev=>prev.map(x=>x.id===q.id?{...x,answer:k}:x))} /> correct
                </label>
              </div>
            ))}
            <div className="flex gap-2"><button className="border px-3 py-2" onClick={()=>updateQuestion(q)}>Save</button><button className="border px-3 py-2" onClick={()=>deleteQuestion(q.id)}>Delete</button></div>
          </div>
        ))}
      </div>
    </div>
  )
}
TSX

cat > src/app/admin/lessons/[id]/quiz/page.tsx <<'TSX'
import { prisma } from "@/lib/prisma"
import { requireAdmin } from "@/lib/auth"
import AdminQuizEditor from "@/components/AdminQuizEditor"
export const runtime = "nodejs"; export const dynamic = "force-dynamic";

export default async function AdminLessonQuiz({ params }: { params: { id: string } }) {
  await requireAdmin()
  const lesson = await prisma.lesson.findUnique({ where: { id: params.id } })
  if (!lesson) return <div className="p-6">Not found</div>
  return (
    <div className="max-w-4xl mx-auto p-6">
      <a className="underline text-sm" href={`/lessons/${lesson.id}`}>‚Üê Back</a>
      <h1 className="text-2xl font-bold mt-2">Admin: {lesson.title} ‚Äî Quiz Editor</h1>
      <AdminQuizEditor lessonId={lesson.id} />
    </div>
  )
}
TSX

echo "‚úÖ Bootstrap complete.

Next steps:
1) Add Secrets in Replit (Tools ‚Üí Secrets):
   - DATABASE_URL = postgresql://USER:PASSWORD@HOST:5432/DB?sslmode=require
   - NEXTAUTH_SECRET = <random 32+ chars>
   - NEXTAUTH_URL = https://<your-repl-subdomain> (shown after first run)
   - NEXT_PUBLIC_SITE_URL = https://<your-repl-subdomain>
   - INVITES_REQUIRED = true
   - EMAIL_FROM = 'Diver Well <no-reply@diverwell.app>'
   - (one) RESEND_API_KEY or EMAIL_SERVER=smtp://USER:PASSWORD@HOST:587

2) Initialize DB + start:
   npm run db:push && npm run db:seed
   npm run dev

Admin:
 - /admin/invites  (create invite ‚Üí share /invite/<token>)
 - /admin/users    (grant/revoke ADMIN, CSV export)
 - /admin/lessons/<lessonId> (edit content)
 - /admin/lessons/<lessonId>/quiz (quiz editor)

User:
 - / (tracks with progress)
 - /tracks/<slug> (progress + lessons)
 - /lessons/<id> (viewer) ‚Üí /lessons/<id>/quiz (take quiz)
"